


		
		
		
			

							
						

			Property (programming)
									
									From Wikipedia, the free encyclopedia
								
												
					Jump to:					navigation, 					search
				
				A property, in some object-oriented programming languages, is a special sort of class member, intermediate between a field (or data member) and a method. Properties are read and written like fields, but property reads and writes are (usually) translated to get and set method calls. The field-like syntax is said to be easier to read and write than lots of method calls, yet the interposition of method calls allows for data validation, active updating (as of GUI visuals), or read-only 'fields'. That is, properties are intermediate between member code (methods) and member data (instance variables) of the class, and properties provide a higher level of encapsulation than public fields.



Contents


1 Support in languages
2 Example syntax

2.1 C#
2.2 C++

2.2.1 C++, Microsoft &amp; C++Builder-specific


2.3 D
2.4 Delphi/Free Pascal
2.5 F#
2.6 JavaScript
2.7 ActionScript 3.0
2.8 Objective-C 2.0
2.9 PHP
2.10 Python
2.11 Ruby
2.12 Visual Basic

2.12.1 Visual Basic (.NET 2003-2010)
2.12.2 Visual Basic (only .NET 2010)
2.12.3 Visual Basic 6




3 See also



Support in languages[edit]
Programming languages that support properties include ActionScript 3, C#, D, Delphi/Free Pascal, F#, JavaScript, Objective-C 2.0, Python, Scala, Swift, Lua, and Visual Basic. Some object-oriented languages, such as Java, don't support properties, and require the programmer to define a pair of accessor and mutator methods instead. Oberon-2 provides an alternative mechanism using object variable visibility flags. Other languages designed for the Java Virtual Machine, such as Groovy, do natively support properties. While C++ doesn't have first class properties, they can be emulated due to operator overloading. Also note that some C++ compilers support first class properties (the Microsoft C++ compiler as an example).
In most languages, properties are implemented as a pair of accessor/mutator methods, but accessed using the same syntax as for public fields. Omitting a method from the pair yields a read-only or an uncommon write-only property.
In some languages with no built-in support for properties, a similar construct can be implemented as a single method that either returns or changes the underlying data, depending on the context of its invocation. Such techniques are used e.g. in Perl.
Some languages (Ruby, Smalltalk) achieve property-like syntax using normal methods, sometimes with a limited amount of syntactic sugar.
Example syntax[edit]
C#[edit]


class Pen 
{
    private int color; // private field
    
    // public property
    public int Color 
    {  
        get
        {
            return this.color;
        }
        set 
        {
            if (value &gt; 0) {
                this.color = value;
            }
        }
    }
}



// accessing:
Pen pen = new Pen();
int color_tmp = 0;
// ...
pen.Color = 17;
color_tmp = pen.Color;
// ...
pen.Color = ~pen.Color; // bitwise complement ...

// another silly example:
pen.Color += 1; // a lot clearer than "pen.set_Color(pen.get_Color() + 1)"!

Recent C# versions also allow "auto-implemented properties" where the backing field for the property is generated by the compiler during compilation. This means that the property must have a setter, however it can be private.


class Shape 
{
    
    public Int32 Height { get; set; }
    public Int32 Width  { get; private set; }
    
}

C++[edit]
C++ does not have first class properties, but there exist several ways to emulate properties to a limited degree. Two of which follow:


#include &lt;iostream&gt;

template &lt;typename T&gt; class property {
        T value;
    public:
        T &amp; operator = (const T &amp;i) {
            ::std::cout &lt;&lt; i &lt;&lt; ::std::endl;
            return value = i;
        }
        // This template class member function template serves the purpose to make
        // typing more strict. Assignment to this is only possible with exact identical
        // types.
        template &lt;typename T2&gt; T2 &amp; operator = (const T2 &amp;i) {
            ::std::cout &lt;&lt; "T2: " &lt;&lt; i &lt;&lt; ::std::endl;
            T2 &amp;guard = value;
            throw guard; // Never reached.
        }

        // Implicit conversion back to T. 
        operator T const &amp; () const {
            return value;
        }
};

struct Foo {
    // Properties using unnamed classes.
    class {
            int value;
        public:
            int &amp; operator = (const int &amp;i) { return value = i; }
            operator int () const { return value; }
    } alpha;

    class {
            float value;
        public:
            float &amp; operator = (const float &amp;f) { return value = f; }
            operator float () const { return value; }
    } bravo;
};

struct Bar {
    // Using the property&lt;&gt;-template.
    property &lt;bool&gt; alpha;
    property &lt;unsigned int&gt; bravo;
};

int main () {
    Foo foo;
    foo.alpha = 5;
    foo.bravo = 5.132f;

    Bar bar;
    bar.alpha = true;
    bar.bravo = true; // This line will yield a compile time error
                      // due to the guard template member function.
    ::std::cout &lt;&lt; foo.alpha &lt;&lt; ", "
                &lt;&lt; foo.bravo &lt;&lt; ", "
                &lt;&lt; bar.alpha &lt;&lt; ", "
                &lt;&lt; bar.bravo
                &lt;&lt; ::std::endl;
    return 0;
}

C++, Microsoft &amp; C++Builder-specific[edit]
An example taken from the MSDN documentation page.


// declspec_property.cpp
struct S
{
   int i;
   void putprop(int j)
   { 
      i = j;
   }

   int getprop()
   {
      return i;
   }

   __declspec(property(get = getprop, put = putprop)) int the_prop;
};

int main()
{
   S s;
   s.the_prop = 5;
   return s.the_prop;
}

D[edit]


class Pen
{
    private int m_color; // private field
    
    // public get property
    public int color () {
        return m_color;
    }
    
    // public set property
    public void color (int value) {
         m_color = value;
    }
}



auto pen = new Pen;
pen.color = ~pen.color; // bitwise complement

// the set property can also be used in expressions, just like regular assignment
int theColor = (pen.color = 0xFF0000);

In D version 2, each property accessor or mutator must be marked with @property:


class Pen
{
    private int m_color; // private field
    
    // public get property
    @property public int color () {
        return m_color;
    }
    
    // public set property
    @property public void color (int value) {
        m_color = value;
    }
}

Delphi/Free Pascal[edit]


type TPen = class
  private
    m_Color: Integer;
    function Get_Color: Integer;
    procedure Set_Color(RHS: Integer);
  public
    property Color: Integer read Get_Color write Set_Color;
end;

function TPen.Get_Color: Integer;
begin
  Result := m_Color
end;

procedure TPen.Set_Color(RHS: Integer);
begin
  m_Color := RHS
end;



// accessing:
var pen: TPen;
// ...
pen.Color := not pen.Color;

(*
Delphi also supports a 'direct field' syntax -

property Color: Integer read m_Color write Set_Color;

or

property Color: Integer read Get_Color write m_Color;

where the compiler generates the exact same code as for reading and writing
a field. This offers the efficiency of a field, with the safety of a property.
(You can't get a pointer to the property, and you can always replace the member
access with a method call.)
*)

F#[edit]


type Pen() = class
    let mutable _color = 0

    member this.Color
        with get() = _color
        and set value = _color &lt;- value
end



let pen = new Pen()
pen.Color &lt;- ~~~pen.Color

JavaScript[edit]


function Pen() {
    this._color = 0;
}
// Add the property to the Pen type itself, can also
// be set on the instance individually
Object.defineProperties(Pen.prototype, {
    color: {
        get: function () {
            return this._color;
        },
        set: function (value) {
            this._color = value;
        }
    }
});



var pen = new Pen();
pen.color = ~pen.color; // bitwise complement
pen.color += 1; // Add one

ActionScript 3.0[edit]


package  {
	public class Pen {
		private var _color:uint = 0;
		
		public function get color():uint {
			return _color;
		}
		
		public function set color(value:uint):void {
			_color = value;
		}
	}
}



var pen:Pen = new Pen();
pen.color = ~pen.color; // bitwise complement
pen.color += 1; // add one

Objective-C 2.0[edit]


@interface Pen : NSObject
@property (copy) NSColor *colour;	// The "copy" attribute causes the object's copy to be
					// retained, instead of the original.
@end

@implementation Pen
@synthesize colour;			// Compiler directive to synthesise accessor methods.
					// It can be left behind in Xcode 4.5 and later.
@end

The above example could be used in an arbitrary method like this:


Pen *pen = [[Pen alloc] init];
pen.colour = [NSColor blackColor];
float red = pen.colour.redComponent;
[pen.colour drawSwatchInRect: NSMakeRect(0, 0, 100, 100)];

PHP[edit]


class Pen {
    private $_color;

    function __set($property, $value) {
        if ($property == 'Color') { 
            return $this-&gt;_color = $value;
        }
    }

    function __get($property) {
        if ($property == 'Color') {
            return $this-&gt;_color;
        }
    }
}



$p = new Pen();
$p-&gt;Color = ~$p-&gt;Color; // bitwise complement
echo $p-&gt;Color;

Python[edit]
Properties only work correctly for new-style classes (classes that have object as a superclass), and are only available in Python 2.2 and newer (see the relevant section of the tutorial Unifying types and classes in Python 2.2). Python 2.6 added a new syntax involving decorators for defining properties.


class Pen(object):
    def __init__(self):
        self._color = 0 # "private" variable

    @property
    def color(self):
        return self._color

    @color.setter
    def color(self, color):
        self._color = color



pen = Pen()
# accessing:
pen.color = ~pen.color # bitwise complement ...

Ruby[edit]


class Pen
    def initialize
        @color = 0
    end
    
    # Defines a getter for the @color field
    def color
        @color
    end

    # Defines a setter for the @color field
    def color=(value)
        @color = value
    end
end

pen = Pen.new
pen.color = ~pen.color    # Bitwise complement

Ruby also provides automatic getter/setter synthesizers defined as instance methods of Class.


class Pen
    attr_reader :brand    # Generates a getter for @brand (Read-Only)
    attr_writer :size     # Generates a setter for @size  (Write-Only)
    attr_accessor :color  # Generates both a getter and setter for @color (Read/Write)

    def initialize
        @color = 0        # Within the object, we can access the instance variable directly
        @brand = "Penbrand"
        @size = 0.7        # But we could also use the setter method defined by the attr_accessor Class instance method
    end
end

pen = Pen.new
puts pen.brand           # Accesses the pen brand through the generated getter
pen.size = 0.5           # Updates the size field of the pen through the generated setter
pen.color = ~pen.color

Visual Basic[edit]
Visual Basic (.NET 2003-2010)[edit]


Public Class Pen
 
    Private _color As Integer ' Private field

    Public Property Color() As Integer ' Public property
        Get
            Return _color
        End Get
        Set(ByVal value As Integer)
            _color = value
        End Set
    End Property

End Class



' Create Pen class instance
Dim pen As New Pen()

' Set value
pen.Color = 1

' Get value
Dim color As Int32 = pen.Color

Visual Basic (only .NET 2010)[edit]


Public Class Pen

    Public Property Color() As Integer ' Public property

End Class



' Create Pen class instance
Dim pen As New Pen()

' Set value
pen.Color = 1

' Get value
Dim color As Int32 = pen.Color

Visual Basic 6[edit]


' in a class named clsPen
Private m_Color As Long

Public Property Get Color() As Long
    Color = m_Color
End Property

Public Property Let Color(ByVal RHS As Long)
    m_Color = RHS
End Property



' accessing:
Dim pen As New clsPen
' ...
pen.Color = Not pen.Color

See also[edit]

Bound property
Field (computer science)
Indexer (programming)
Method (computer programming)
Mutator method
Uniform access principle








					
						Retrieved from "https://en.wikipedia.org/w/index.php?title=Property_(programming)&amp;oldid=691064309"					
				Categories: Object-oriented programming				
							
		
		
			